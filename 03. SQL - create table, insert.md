# Глава 3. Создаём таблицы и наполняем их данными

Любая база данных состоит из таблиц. Каждая таблица представляет собой набор строк и именованных столбцов (каждый столбец содержит определённый тип данных и называется полем, каждая строка содержит информацию в каждом поле, характеризующую отдельно взятый объект, и называется записью). Порядок столбцов в таблице фиксируется при её создании (или изменении). Таблицы объединяются в базу данных, а набор баз данных, управляемых одним экземпляром сервера PostgreSQL, называется кластером баз данных. Учтите, что если вы создаёте свою базу данных на учебном компьютере, то это не означает, что она будет находиться там в гордом одиночестве: студенты других групп тоже могут прийти в эту же аудиторию и, работая за тем же компьютером, создать на нём свои базы данных. Следовательно, в любой непонятной ситуации относитесь к локальному серверу PostgreSQL как к кластеру и в случае каких-либо неполадок старайтесь решить возникшие проблемы без переустановки СУБД. Этот опыт вам потом пригодится.

Этот учебник не ставит своей целью (по крайней мере, пока) рассмотрение теории реляционных баз данных - всё, что здесь написано, нужно для того, чтобы после внимательного прочтения всех глав и повторения описанных там действий вы смогли создать собственную базу данных для проекта средней сложности. Теория, особенно в том виде, как она описана во многих современных учебниках (в стиле "если A, то Z", без объяснения всех промежуточных этапов), скорее затрудняет понимание сути, чем раскрывает её. Поэтому мы пройдём все этапы от создания "неправильной" базы данных до её оптимизации до так называемой третьей нормальной формы (3NF). О том, что называется нормальной формой и какие они бывают, вы без труда найдёте огромное количество материала в интернете (однако придётся потрудиться, чтобы всё это понять), так что я оставляю этот вопрос вам для самостоятельного изучения.

Начнём мы с создания базы данных для ведения расписания учебного заведения (колледжа, техникума, вуза - УЗ, в которых занятия планируются не отдельными уроками, а "парами", т.е. по два часа). Итак, базы данных хранят всю информацию в таблицах, поэтому мы тоже составим одну таблицу, в которую и будем записывать все занятия, которые были запланированы (поставлены в расписание). Нам понадобится такая информация:

* номер записи;
* дата, в которую проводится занятие;
* номер пары, на которую поставлено занятие;
* ФИО преподавателя, который проводит занятие;
* номер группы, у которой пройдёт занятие;
* аудитория, где пройдёт пара (это не обязательно номер аудитории, здесь может быть дополнительная буква, например, 112а, или может быть указан номер корпуса, например 18/2);
* учебный предмет, занятие по которому пройдёт у этой группы с указанным преподавателем.

В таблице есть строки и столбцы. В базе данных каждая строка - это запись о каком-то одном объекте, а столбец - это одно из свойств однородных объектов. То есть в нашей таблице будут следующие столбцы:

* id
* date
* pair_num
* fio_prep
* group_num
* aud_num
* predmet

При создании таблицы задаются её уникальное (в пределах базы данных) имя, структура (имена столбцов, тип каждого столбца, ограничения на вводимые данные, которые должны контролироваться СУБД при заполнении и редактировании данных). Общий вид команды, создающей таблицу, следующий:
```
CREATE TABLE table_name
(
  имя_столбца тип_столбца [DEFAULT значение_по_умолчанию] [ограничения_на_столбец],
  имя_столбца тип_столбца [DEFAULT значение_по_умолчанию] [ограничения_на_столбец]
);
```
Все строки (кроме последней), описывающие поле (столбец таблицы), заканчиваются запятой.

Отдельно нужно сказать про типы данных. В SQL определено большое число всевозможных типов полей, однако список типов, реально поддерживаемых конкретной СУБД, нужно искать в документации к ней. В стандарте SQL описаны следующие типы: bigint, bit, bit varying, boolean, char, character varying, character, varchar, date, double precision, integer, interval, numeric, decimal, real, smallint, time (с часовым поясом и без), timestamp (с часовым поясом и без), xml. Однако многие СУБД поддерживают большое разнообразие других типов. Это создаёт бОльшую свободу, а заодно сильно затрудняет перенос чего бы то ни было (начиная от кода программ и заканчивая самими программами с их базами данных) на другой SQL-движок. Вот такая конкуренция.

Создадим таблицу "raspisanie" указав её имя и перечислив все имена столбцов и их типы. Кстати, это неправильно, такие названия, когда русские слова пишутся латинскими буквами, давать чему-либо нельзя, есть даже разъяснения в стандартах про это, но мы ведь сейчас делаем "неправильную" базу данных, поэтому сделаем в ней всё неправильно - по принципу "работает? - не трожь!" Однако помните, что в реальной жизни такой стиль названий объектов в вашей программе будет говорить о вашем невысоком уровне как программиста - прежде всего потому, что вы не соблюдаете инструкции, работаете "по-своему", и большой вопрос - выйдет ли из этого что-то хорошее. Итак, создаём таблицу:

```
CREATE TABLE raspisanie (
    id SERIAL,            -- эта реализация счётчика будет рассмотрена отдельно
    date date,            -- дата занятия
    pair_num smallint,    -- номер пары в течение учебного дня
    fio_prep varchar(80), -- фамилия, имя, отчество преподавателя
    group_num varchar(5), -- номер группы
    aud_num varchar(10),  -- номер аудитории (здесь также может быть зашифрован корпус и др.)
    predmet varchar(80)   -- название предмета
); -- очень легко забыть про эту незаметную точку с запятой в конце, а потом удивляться
   -- что же здесь не так? что от меня хочет этот компьютер?
```
Теперь команда 
```
select * from raspisanie;
```
выведет нам пустую таблицу:
```
 id | date | pair_num | fio_prep | group_num | aud_num | predmet 
----+------+----------+----------+-----------+---------+---------
(0 rows)
```
Таблица создана, теперь нам нужно научиться работать с ней - добавлять данные и извлекать информацию.

За добавление строк отвечает оператор INSERT:

```
INSERT INTO raspisanie (date, pair_num, fio_prep, group_num, aud_num, predmet)
VALUES ('2024-10-31',1,'Иванов Иван Иванович',111,'25-2','Математика (1 год обучение)');
```
Здесь мы вставляем в таблицу raspisanie в поля, перечисленные в первой паре круглых скобочек, значения, идущие во второй паре круглых скобочек. Обратите внимание, что поле id мы не заполняем - СУБД сама внесёт в него требуемое значение. Если мы хотим добавить не одну, а сразу несколько записей (это может понадобиться, если у нас есть набор исходных данных и мы его откуда-то импортируем), то команда будет выглядеть следующим образом:

```
INSERT INTO raspisanie (date, pair_num, fio_prep, group_num, aud_num, predmet)
VALUES ('2024-10-31',1,'Иванов Иван Иванович',111,'25-2','Математика (1 год обучения)'),
('2024-10-31',2,'Иванова Лидия Ивановна',111,'143','Русский язык');
```
В стандарте SQL существует свойство поля AUTO_INCREMENT, работающее как счётчик записей в таблице. В PostgreSQL вместо него используются типы smallserial, serial и bigserial (на самом деле, это не настоящие типы, а просто удобный способ записи для создания столбцов уникальных идентификаторов). В нашей таблице мы указали, для поля id тип serial, что специфично для PostgreSQL. Итак, В текущей реализации запись:
```
CREATE TABLE имя_таблицы (
имя_столбца SERIAL
);
```
равнозначна следующим командам:
```
CREATE SEQUENCE имя_таблицы_имя_столбца_seq AS integer;
CREATE TABLE имя_таблицы (
имя_столбца integer NOT NULL DEFAULT nextval('имя_таблицы_имя_столбца_seq')
);
ALTER SEQUENCE имя_таблицы_имя_столбца_seq OWNED BY имя_таблицы.имя_столбца;
```
