# Как пройти... к третьей нормальной форме?

При разработке базы данных самым сложным является разработка такой её структуры (описание таблиц и их полей), чтобы при изменениях можно было только добавлять новые таблицы и записи, не меняя сложившиеся структуру и взаимосвязи между уже имеющимися. Помогает этому так называемая нормализация таблиц, то есть система правил, когда выполнение того или иного набора правил соответствует той или иной нормальной форме (чем больше номер формы, тем шире набор правил, которые должны соблюдаться).  В литературе выделяется шесть или даже больше нормальных форм, однако в большинстве случаев достаточно доведения базы данных до третьей нормальной формы, а в отдельных случаях приходится даже проводить денормализацию таблиц, чтобы повысить производительность. В общем, нормальная форма — ещё не истина в последней инстанции, это всего лишь правило, и его иногда можно нарушать.
Отойдём ненадолго от теории, разберём на практике несколько примеров разработки баз данных. И начнём мы с хорошо известного преподавателям примера — базы данных о расписании занятий учебного заведения. Прежде всего, разберёмся, с какой информацией мы бы хотели работать.
Предположим, что есть некоторое учебное заведение, диспетчер которого, составляя расписание, стыкует преподавателей, аудитории, учебные группы и предметы, по которым ведётся занятие. Руководство учебного заведения обратилось к вам, как к разработчику баз данных, с просьбой посодействовать созданию эффективного приложения, способного легко и просто формировать расписание занятий на любой грядущий день учебного года.
Сегодня «база данных», если её так можно назвать, ведётся в таблице Excel и занимает ровно одну вкладку, где содержится таблица со следующими заголовками (таблица 1):

Таблица 1. Исходная структура базы данных
Дата
Номер пары
ФИО преподавателя
№ группы
№ кабинета
Предмет
Примечания








В целом, это рабочая схема, хотя о её качестве лучше промолчать. Посмотрим теперь на фрагмент этой таблицы с заполненными данными (таблица 2):

Таблица 2. Фрагмент базы данных с внесённой в неё информацией
Дата
Номер пары
ФИО преподавателя
№ группы
№ кабинета
Предмет
Примечания
12.02
1
Иванов И.И
111
24
история

12.02
2
Иванов И.И
111
24
история

12.02
3
Иванов И.И
112
24
экономика

12.02
4
Иванов И.И
112
24
экономика

12.02
1
Петров А.Я.
114
26
физика

12.02
2
Петров А.Я.
114
26
физика

12.02
3
Петров А.Я.
115
19
физика

12.02
4
Петров А.Я.
115
19
физика

12.02
3
Сидоров О.И.
114
26
алгебра

12.02
4
Сидоров О.И.
114
26
алгебра

12.02
5
Сидоров О.И.
115
26
алгебра

12.02
6
Сидоров О.И.
115
26
алгебра


Обратим внимание на то, что в этой таблице очень много повторений. Например, у нас небольшое количество преподавателей, кабинетов, учебных предметов, номеров пар, а дата в этом фрагменте так вообще одна. Можно «зашифровать» такие поля как «ФИО преподавателя» и «Предмет», и вынести их в отдельные таблицы (см. таблицы 3-4):
Таблица 3. Преподаватели
ФИО преподавателя
TeacherID
Иванов И.И.
001
Петров А.Я.
002
Сидоров О.И.
003
Примечание: в целях упрощения я привожу в качестве ID_prep порядковые номера, однако помним, что это — плохая практика, в ряде случаев она может привести к недоразумениям и серьёзным ошибкам!

Таблица 4. Предметы
Название предмета
SubjectID
история
001
экономика
002
физика
003
алгебра
004

Обратим внимание, что два поля, указывающие на время, когда состоялось (или планируется) занятие, можно объединить и вынести в отдельную таблицу (таблица 5):

Таблица 5. Дата и время занятия
Дата
Номер пары
LessonID
12.02
1
001
12.02
2
002
12.02
3
003
12.02
4
004
12.02
5
005
12.02
6
006

Теперь наша база данных представляет собой несколько таблиц — по преподавателям (таблица 3), по предметам (таблица 4), по датам и времени занятий (таблица 5). В принципе, можно было не объединять дату и номер пары, использовав ID для даты и ID для номера пары (собственно, номер пары сам себе является ID). Перепишем наш фрагмент базы данных, подставив вместо исходных значений номера соответствующих идентификаторов (таблица 6).

Таблица 6. Фрагмент базы данных (улучшенной) с внесённой в неё информацией
LessonID
TeacherID
№ группы
№ кабинета
SubjectID
Примечания
001
001
111
24
001

002
001
111
24
001

003
001
112
24
002

004
001
112
24
002

001
002
114
26
003

002
002
114
26
003

003
002
115
19
003

004
002
115
19
003

003
003
114
26
004

004
003
114
26
004

005
003
115
26
004

006
003
115
26
004


Мы видим, что в такой таблице отсутствует индекс. Теоретически, в таком качестве можно было бы использовать связку полей LessonID и TeacherID (а, возможно, и других), однако во-первых, где гарантия, что в результате ошибки не появятся дубли (т. е. не будет нарушена целостность таблицы)? А во-вторых, если мы в качестве индекса возьмём большое количество полей, в дальнейшем это может препятствовать расширению базы данных (вам будет сложнее добавлять в эту базу новую информацию, поскольку требованием уникальности значений в полях записи, заявленных в индексе, вы наложите на таблицу и её значения серьёзные ограничения, что вызовет сложности в изменении этой таблицы (как минимум, придётся пересчитывать индексы при каждом подобном изменении, что далеко не всегда оправдано). В нашей ситуации есть смысл добавить в таблицу индексное поле — это будет синтетический, или искусственный индекс, представляющий собой поле, содержащее значение счётчика. Конкретно в этой таблице синтетический счётчик ничего не «сломает», почему — расскажу немного позже.
Обратим внимание, что большинство преподавателей занимается строго в своих кабинетах (хотя некоторые преподаватели не имеют «своего» кабинета, поэтому им назначают занятия в разных кабинетах). Можем также вынести эти данные в новую таблицу (таблица 7).

Таблица 7. Закрепление кабинетов за преподавателями
AudienceID
Номер_кабинета
TeacherID
1
19
002
2
24
001
3
26
002
4
26
003

Ну и последний штрих: создадим отдельную таблицу для примечаний, куда будем вносить информацию, не нашедшую места в расписании (выделять для этого целое поле в исходной таблице — верх нерациональности). Хранение значения «1» вместо текстового поля размером в несколько килобайт для каждого занятия не только экономит память, но и поможет в дальнейшем ускорить поиск информации по этому полю.

Таблица 8. Примечания
NoteID
Текст примечания
1
<пусто>

Тогда наша основная таблица с расписанием приобретёт следующий вид:

Таблица 9. Фрагмент базы данных (вновь улучшенной) с откорректированной информацией
ID
LessonID
AudienceID
№ группы
SubjectID
NoteID
1
001
2
111
001
1
2
002
2
111
001
1
3
003
2
112
002
1
4
004
2
112
002
1
5
001
3
114
003
1
6
002
3
114
003
1
7
003
1
115
003
1
8
004
1
115
003
1
9
003
4
114
004
1
10
004
4
114
004
1
11
005
4
115
004
1
12
006
4
115
004
1

Аналогичным образом можно поступить и с номером группы. Более того, сейчас мы про группу ничего не знаем — ни какой это курс, ни какая специальность, ни сколько человек учится в этой группе, а это очень важная информация для составления расписания! Если бы мы продолжали работать со старой таблицей (см. табл. 2), добавление этой информации о группе привело бы к раздуванию таблицы минимум на три поля, и эта информация, дублируясь, не только заняла бы лишнее место в памяти сервера и на диске, но и замедлила бы поиск нужных записей. Для того, чтобы закрепить полученные знания, выполните подобную оптимизацию наших таблиц самостоятельно. Как будет выглядеть итоговая таблица, где мы регистрируем все занятия? А какие вспомогательные таблицы будут её дополнять? Как будет выглядеть каждая из них?
Если вы попробуете нарисовать схему хранения информации в этой системе таблиц, вы увидите, что есть одна большая таблица — можно сказать, что она главная, в ней содержится информация о событиях, для регистрации которых и создаётся база данных, и есть множество мелких таблиц, что-то уточняющих и дополняющих, имеющих второстепенное значение по отношению к первой. Я называю эти мелкие таблицы справочниками. Итак, повторю: в одной большой таблице мы регистрируем СОБЫТИЯ, тогда как множество мелких таблиц, дополняющих её, являются СПРАВОЧНИКАМИ. Понимание этого очень важно при проектировании базы данных.
Приступая к проектированию базы данных, старайтесь прежде всего обнаружить, что является СОБЫТИЕМ. Могу дать подсказку: событие — это нечто достаточно уникальное, неповторимое, происходящее много-много-много раз. Собственно говоря, СОБЫТИЕ — это то, ради чего и создаётся вся база данных, и в корректно разработанной базе данных у вас будет только одно СОБЫТИЕ, не больше и не меньше, поскольку оно является «ядром» всей базы, единственным, неповторимым и неделимым. В некоторых базах данных можно обнаружить два события и даже более, но, разобравшись с этими базами, вы увидите, что у них более одного «ядра» (например, вы пишете базу данных для больницы — а там есть отдельно аптека и выписка лекарств, и по хорошему это должна быть одна база, есть врачи, пациенты, приёмы и назначения лекарств — это другая база, есть процедурные кабинеты, процедуры и тому подобное — это ещё одна база, а то и несколько. Справочником можно назвать любую другую таблицу базы данных (не являющуюся СОБЫТИЕМ). Нередко студенты путаются, не могут определить, что является справочником — им кажется, что половина таблиц их базы — СОБЫТИЯ. Это неверно. Причиной подобных ошибок является то, что тогда как таблица, описывающая СОБЫТИЕ, растёт при каждом добавлении в базу информацию, некоторые справочники также имеют обыкновение расти вместе с главной таблицей, хотя и делают это несколько медленнее. Предположим, вы проектируете базу данных для республиканской больницы — в качестве СОБЫТИЯ будут выступать случаи приёма специалистом пациента, однако почти так же быстро, как и главная таблица, будет расти справочник по пациентам — в силу того, что большинство из них обратится в больницу один раз в своей жизни (для этого им пришлось ехать в другой город, обращение было неотложным, в экстренных случаях они вообще сюда не доедут, а в менее сложных случаях обратятся за помощью по месту жительства). Не нужно пугаться того, что какой-то справочник растёт быстро, это нормально.
Преимущества деления всех таблиц на СОБЫТИЕ и справочники заключается в том, что вы всегда понимаете, где и как можно и нужно расширить таблицу для внесения в неё дополнительной информации.
Возьмём пример с нашей базой данных, описанной таблицами 3-5 и 7-9: девятая таблица описывает СОБЫТИЕ (занятие, проведённое в конкретную дату, на конкретной паре, конкретным преподавателем, в конкретной группе, в конкретной аудитории), а все остальные по отношению к ней являются справочниками. Любой справочник может быть дополнен и расширен, причём это не затронет главную таблицу — в ней по-прежнему останется ссылка на справочник. Покажу это на примере таблицы 7 (закрепление кабинетов за преподавателями). Предположим, что в некоторых кабинетах есть проектор, и  выясняется, что преподавателю с TeacherID=2 очень важно, чтобы в кабинете, где он проводит занятие, проектор имелся. Тогда мы добавим в справочник, содержащий информацию о кабинетах, столбец ProjectorAvailability («Наличие проектора» (да/нет):
Таблица 10. Закрепление кабинетов за преподавателями (дополненная версия)
AudienceID
Номер_кабинета
TeacherID
ProjectorAvailability
1
19
002
No
2
24
001
No
3
26
002
Yes
4
26
003
Yes

Как мы видим, преподавателю с TeacherID = 002 ставили занятия в 19 и 26 кабинетах, однако в первом проектор отсутствует, следовательно, диспетчер в следующий раз составит расписание таким образом, чтобы этот преподаватель вёл занятия именно в 26 кабинете. Ну и в целом, в этом примере мы также видим, что изначально составленная таблица, объединяющая и кабинеты, и преподавателей, «разъезжается» на два разных справочника (во всяком случае, из неё хочется изъять TeacherID как нечто, не имеющее отношения к кабинету). В базах данных не может быть «правильной» и «неправильной» структуры данных — она может быть более и менее эффективная, легко или сложно поддерживаемая (подвергающаяся изменениям).

